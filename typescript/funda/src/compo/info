
/*
npx create-react-app my-app --template typescript

JavaScript only truly provides dynamic typing - running 
the code to see what happens.

The alternative is to use a static type system to make 
predictions about what code is expected before it runs.

Of course, over time, you may want to be a bit more
defensive against mistakes, and make TypeScript act a 
bit more strictly. In that case, you can use thenoEmitOnError 
compiler option. Try changing your hello.ts file and 
running tsc with that flag:

tsc --noEmitOnError hello.ts

Explicit Types
Up until now, we haven't told TypeScript what person or 
date are. Let's edit the code to tell TypeScript that person 
is a string , and that date should be a Date object. We'll 
also use the toDateString() method on date .

function greet(person: string, date: Date) {
          console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

What we did was add type annotations on person and date 
to describe what types of values greet can be called with. 

You can read that signature as " greet takes a person of type
string , and a date of type Date ".

Keep in mind, we don't always have to write explicit type 
annotations. In many cases, TypeScript can even just infer 
(or "figure out") the types for us even if we omit them.

let msg = "hello there!"; //let msg: string

Even though we didn't tell TypeScript that msg had the type 
string it was able to figure that out. That's a feature, and it's 
best not to add annotations when the type system would end 
up inferring the same type anyway.

Notice two things here:
1. Our person and date parameters no longer have type 
annotations.

2. Our "template string" - that string that used backticks 
(the ` character) - was converted to plain strings with 
concatenations ( + ).

*/ 