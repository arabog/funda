
/*
npx create-react-app my-app --template typescript

JavaScript only truly provides dynamic typing - running 
the code to see what happens.

The alternative is to use a static type system to make 
predictions about what code is expected before it runs.

Of course, over time, you may want to be a bit more
defensive against mistakes, and make TypeScript act a 
bit more strictly. In that case, you can use thenoEmitOnError 
compiler option. Try changing your hello.ts file and 
running tsc with that flag:

tsc --noEmitOnError hello.ts

Explicit Types
Up until now, we haven't told TypeScript what person or 
date are. Let's edit the code to tell TypeScript that person 
is a string , and that date should be a Date object. We'll 
also use the toDateString() method on date .

function greet(person: string, date: Date) {
          console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

What we did was add type annotations on person and date 
to describe what types of values greet can be called with. 

You can read that signature as " greet takes a person of type
string , and a date of type Date ".

Keep in mind, we don't always have to write explicit type 
annotations. In many cases, TypeScript can even just infer 
(or "figure out") the types for us even if we omit them.

let msg = "hello there!"; //let msg: string

Even though we didn't tell TypeScript that msg had the type 
string it was able to figure that out. That's a feature, and it's 
best not to add annotations when the type system would end 
up inferring the same type anyway.

Notice two things here:
1. Our person and date parameters no longer have type 
annotations.

2. Our "template string" - that string that used backticks 
(the ` character) - was converted to plain strings with 
concatenations ( + ).

TypeScript has several type-checking strictness flags 
that can be turned on or off, and all of our examples 
will be written with all of them enabled unless otherwise 
stated. The strict flag in the CLI, or "strict": true in a 
tsconfig.json toggles them all on simultaneously, but we 
can opt out of them individually. The two biggest ones 
you should know about are noImplicitAny and strictNullChecks.

noImplicitAny
Recall that in some places, TypeScript doesn't try to infer 
types for us and instead falls back to the most lenient 
type: any . This isn't the worst thing that can happen - 
after all, falling back to any is just the plain JavaScript 
experience anyway.

strictNullChecks
By default, values like null and undefined are assignable 
to any other type. This can make writing some code easier, 
but forgetting to handle null and undefined is the cause of 
countless bugs in the world - some consider it a billion dollar 
mistake! The strictNullChecks flag makes handling null and 
undefined more explicit, and spares us from worrying about 
whether we forgot to handle null and undefined


*/ 