
/*
npx create-react-app my-app --template typescript

JavaScript only truly provides dynamic typing - running 
the code to see what happens.

The alternative is to use a static type system to make 
predictions about what code is expected before it runs.

Of course, over time, you may want to be a bit more
defensive against mistakes, and make TypeScript act a 
bit more strictly. In that case, you can use thenoEmitOnError 
compiler option. Try changing your hello.ts file and 
running tsc with that flag:

tsc --noEmitOnError hello.ts

Explicit Types
Up until now, we haven't told TypeScript what person or 
date are. Let's edit the code to tell TypeScript that person 
is a string , and that date should be a Date object. We'll 
also use the toDateString() method on date .

function greet(person: string, date: Date) {
          console.log(`Hello ${person}, today is ${date.toDateString()}!`);
}

What we did was add type annotations on person and date 
to describe what types of values greet can be called with. 

You can read that signature as " greet takes a person of type
string , and a date of type Date ".

Keep in mind, we don't always have to write explicit type 
annotations. In many cases, TypeScript can even just infer 
(or "figure out") the types for us even if we omit them.

let msg = "hello there!"; //let msg: string

Even though we didn't tell TypeScript that msg had the type 
string it was able to figure that out. That's a feature, and it's 
best not to add annotations when the type system would end 
up inferring the same type anyway.

Notice two things here:
1. Our person and date parameters no longer have type 
annotations.

2. Our "template string" - that string that used backticks 
(the ` character) - was converted to plain strings with 
concatenations ( + ).

TypeScript has several type-checking strictness flags 
that can be turned on or off, and all of our examples 
will be written with all of them enabled unless otherwise 
stated. The strict flag in the CLI, or "strict": true in a 
tsconfig.json toggles them all on simultaneously, but we 
can opt out of them individually. The two biggest ones 
you should know about are noImplicitAny and strictNullChecks.

noImplicitAny
Recall that in some places, TypeScript doesn't try to infer 
types for us and instead falls back to the most lenient 
type: any . This isn't the worst thing that can happen - 
after all, falling back to any is just the plain JavaScript 
experience anyway.

strictNullChecks
By default, values like null and undefined are assignable 
to any other type. This can make writing some code easier, 
but forgetting to handle null and undefined is the cause of 
countless bugs in the world - some consider it a billion dollar 
mistake! The strictNullChecks flag makes handling null and 
undefined more explicit, and spares us from worrying about 
whether we forgot to handle null and undefined


-: Type Assertions

Sometimes you will have information about the type of a value 
that TypeScript can't know about.
For example, if you're using document.getElementById , TypeScript 
only knows that this will return some kind of HTMLElement , but 
you might know that your page will always have an
HTMLCanvasElement with a given ID.

In this situation, you can use a type assertion to specify a more 
specific type:

const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement

You can also use the angle-bracket syntax (except if the code is in a .tsx file), 
which is equivalent:

const myCanvas = <HTMLCanvasElement>document.getElementById("main_canvas")

Reminder: Because type assertions are removed at compile-time, there is 
no runtime checking associated with a type assertion. There won't be an 
exception or null generated if the type assertion is wrong.

function printAll(strs: string | string[] | null) {
          if (typeof strs === "object") {
                    for (const s of strs) {
                              <!-- Error: Object is possibly 'null'. -->
                              console.log(s);
                    }
          } else if (typeof strs === "string") {
                    console.log(strs);
          } else {
                    // do nothing
          }
}

In the printAll function, we try to check if strs is an object to 
see if it's an array type (now might be a good time to reinforce 
that arrays are object types in JavaScript). But it turns out that in
JavaScript, typeof null is actually "object" ! This is one of those 
unfortunate accidents of history.


-: Truthiness narrowing
In JavaScript, constructs like if first "coerce" their conditions 
to boolean s to make sense of them, and then choose their 
branches depending on whether the result is true or false . 
Values like
0
NaN
"" (the empty string)
0n (the bigint version of zero)
null
undefined

all coerce to false , and other values get coerced true . You can 
always coerce values to boolean s by running them through the 
Boolean function, or by using the shorter double-Boolean negation.

// both of these result in 'true'
Boolean("hello"); // type: boolean, value: true

!!"world"; // type: true, value: true

It's fairly popular to leverage this behavior, especially for guarding 
against values like null or undefined . As an example, let's try using 
it for our printAll function.

function printAll(strs: string | string[] | null) {
          if (strs && typeof strs === "object") {
                    for (const s of strs) {
                              console.log(s);
                    }
          } else if (typeof strs === "string") {
                    console.log(strs);
          }
}

You'll notice that we've gotten rid of the error above by checking 
if strs is truthy. This at least prevents us from dreaded errors when 
we run our code like:
TypeError: null is not iterable

Keep in mind though that truthiness checking on primitives can often 
be error prone.


-: Equality narrowing
TypeScript also uses switch statements and equality checks like === , 
!== , == , and != to narrow types. For example:


cont on page 43
*/ 